// Copyright (c) 2022 Tailscale Inc & AUTHORS All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by tailscale.com/util/codegen (cloner); DO NOT EDIT.

package tests

import (
	"inet.af/netaddr"
)

// Clone makes a deep copy of Value.
// The result aliases no memory with the original.
func (src *Value) Clone() *Value {
	if src == nil {
		return nil
	}
	dst := new(Value)
	*dst = *src
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ValueCloneNeedsRegeneration = Value(struct {
	Int int
	Pfx netaddr.IPPrefix
}{})

// Clone makes a deep copy of Struct.
// The result aliases no memory with the original.
func (src *Struct) Clone() *Struct {
	if src == nil {
		return nil
	}
	dst := new(Struct)
	*dst = *src
	if dst.Value != nil {
		dst.Value = new(Value)
		*dst.Value = *src.Value
	}
	if dst.Int != nil {
		dst.Int = new(int)
		*dst.Int = *src.Int
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _StructCloneNeedsRegeneration = Struct(struct {
	Value *Value
	Int   *int
}{})

// Clone makes a deep copy of Map.
// The result aliases no memory with the original.
func (src *Map) Clone() *Map {
	if src == nil {
		return nil
	}
	dst := new(Map)
	*dst = *src
	if dst.M != nil {
		dst.M = map[string]int{}
		for k, v := range src.M {
			dst.M[k] = v
		}
	}
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MapCloneNeedsRegeneration = Map(struct {
	M map[string]int
}{})

// Clone makes a deep copy of Slices.
// The result aliases no memory with the original.
func (src *Slices) Clone() *Slices {
	if src == nil {
		return nil
	}
	dst := new(Slices)
	*dst = *src
	dst.Values = append(src.Values[:0:0], src.Values...)
	dst.ValuePointers = make([]*Value, len(src.ValuePointers))
	for i := range dst.ValuePointers {
		dst.ValuePointers[i] = src.ValuePointers[i].Clone()
	}
	dst.StructPointers = make([]*Struct, len(src.StructPointers))
	for i := range dst.StructPointers {
		dst.StructPointers[i] = src.StructPointers[i].Clone()
	}
	dst.Structs = make([]Struct, len(src.Structs))
	for i := range dst.Structs {
		dst.Structs[i] = *src.Structs[i].Clone()
	}
	dst.Ints = make([]*int, len(src.Ints))
	for i := range dst.Ints {
		x := *src.Ints[i]
		dst.Ints[i] = &x
	}
	dst.Slice = append(src.Slice[:0:0], src.Slice...)
	dst.Prefixes = append(src.Prefixes[:0:0], src.Prefixes...)
	dst.Data = append(src.Data[:0:0], src.Data...)
	return dst
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _SlicesCloneNeedsRegeneration = Slices(struct {
	Values         []Value
	ValuePointers  []*Value
	StructPointers []*Struct
	Structs        []Struct
	Ints           []*int
	Slice          []string
	Prefixes       []netaddr.IPPrefix
	Data           []byte
}{})
