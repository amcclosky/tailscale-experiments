// Copyright (c) 2022 Tailscale Inc & AUTHORS All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by tailscale.com/util/codegen (viewer); DO NOT EDIT.

package tests

import (
	"encoding/json"
	"errors"

	"go4.org/mem"
	"inet.af/netaddr"
	"tailscale.com/types/views"
)

//go:generate go run tailscale.com/cmd/cloner  -clonefunc=false -type=Value,Struct,Map,Slices
// View returns a readonly view of Value.
func (p *Value) View() ValueView {
	return ValueView{ж: p}
}

// ValueView provides a read-only view on Value.
// It's methods should only be called if `Valid()` returns true.
type ValueView struct {
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Value
}

// Valid reports whether underlying value is non-nil.
func (v ValueView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v ValueView) AsStruct() *Value {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v ValueView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *ValueView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Value
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v ValueView) Int() int              { return v.ж.Int }
func (v ValueView) Pfx() netaddr.IPPrefix { return v.ж.Pfx }

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ValueViewNeedsRegeneration = Value(struct {
	Int int
	Pfx netaddr.IPPrefix
}{})

// View returns a readonly view of Struct.
func (p *Struct) View() StructView {
	return StructView{ж: p}
}

// StructView provides a read-only view on Struct.
// It's methods should only be called if `Valid()` returns true.
type StructView struct {
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Struct
}

// Valid reports whether underlying value is non-nil.
func (v StructView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v StructView) AsStruct() *Struct {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v StructView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *StructView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Struct
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v StructView) Value() *Value {
	if v.ж.Value == nil {
		return nil
	}
	x := *v.ж.Value
	return &x
}

func (v StructView) Int() *int {
	if v.ж.Int == nil {
		return nil
	}
	x := *v.ж.Int
	return &x
}

func (v StructView) String() string           { return v.ж.String() }
func (v StructView) Equal(v2 StructView) bool { return v.ж.Equal(v2.ж) }

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _StructViewNeedsRegeneration = Struct(struct {
	Value *Value
	Int   *int
}{})

// View returns a readonly view of Map.
func (p *Map) View() MapView {
	return MapView{ж: p}
}

// MapView provides a read-only view on Map.
// It's methods should only be called if `Valid()` returns true.
type MapView struct {
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Map
}

// Valid reports whether underlying value is non-nil.
func (v MapView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v MapView) AsStruct() *Map {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v MapView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *MapView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Map
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _MapViewNeedsRegeneration = Map(struct {
	M map[string]int
}{})

// View returns a readonly view of Slices.
func (p *Slices) View() SlicesView {
	return SlicesView{ж: p}
}

// SlicesView provides a read-only view on Slices.
// It's methods should only be called if `Valid()` returns true.
type SlicesView struct {
	// It is named distinctively to make you think of how dangerous it is to escape
	// to callers. You must not let callers be able to mutate it.
	ж *Slices
}

// Valid reports whether underlying value is non-nil.
func (v SlicesView) Valid() bool { return v.ж != nil }

// AsStruct returns a clone of the underlying value which aliases no memory with
// the original.
func (v SlicesView) AsStruct() *Slices {
	if v.ж == nil {
		return nil
	}
	return v.ж.Clone()
}

func (v SlicesView) MarshalJSON() ([]byte, error) { return json.Marshal(v.ж) }

func (v *SlicesView) UnmarshalJSON(b []byte) error {
	if v.ж != nil {
		return errors.New("already initialized")
	}
	if len(b) == 0 {
		return nil
	}
	var x Slices
	if err := json.Unmarshal(b, &x); err != nil {
		return err
	}
	v.ж = &x
	return nil
}

func (v SlicesView) Values() views.Slice[Value] { return views.SliceOf(v.ж.Values) }
func (v SlicesView) ValuePointers() views.ViewSlice[*Value, ValueView] {
	return views.SliceOfViews[*Value, ValueView](v.ж.ValuePointers)
}
func (v SlicesView) StructPointers() views.ViewSlice[*Struct, StructView] {
	return views.SliceOfViews[*Struct, StructView](v.ж.StructPointers)
}
func (v SlicesView) Structs() Struct               { panic("unsupported") }
func (v SlicesView) Ints() *int                    { panic("unsupported") }
func (v SlicesView) Slice() views.Slice[string]    { return views.SliceOf(v.ж.Slice) }
func (v SlicesView) Prefixes() views.IPPrefixSlice { return views.IPPrefixSliceOf(v.ж.Prefixes) }
func (v SlicesView) Data() mem.RO                  { return mem.B(v.ж.Data) }

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _SlicesViewNeedsRegeneration = Slices(struct {
	Values         []Value
	ValuePointers  []*Value
	StructPointers []*Struct
	Structs        []Struct
	Ints           []*int
	Slice          []string
	Prefixes       []netaddr.IPPrefix
	Data           []byte
}{})
